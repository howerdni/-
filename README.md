# -
DIgSILENT based 电网动态仿真测试平台-苏州电网
# 苏州电网 DIgSILENT 平台

## **1. 项目简介**

本项目旨在构建一个基于 **DIgSILENT PowerFactory** 的苏州电网仿真平台，能够进行潮流分析、动态稳定性（机电、电磁暂态）仿真，并包含 **VSC**（电压源换流器）、**LCC**（换相换流器）及 **风电模型** 等新型电力系统组件。通过等值建模技术，优化电网的计算效率，同时保留关键节点的动态特性，为电力规划、稳定性分析和新能源接入评估提供有力支持。

## **2. 苏州电网概述**

苏州电网位于中国华东地区，承担着江苏省重要的电力供应任务。其主要特点包括：

- **高负荷密度**：作为长三角经济圈的核心城市之一，苏州拥有高工业和商业负荷，昼夜负荷波动显著。
- **交直流混合系统**：电网中集成了 **LCC-HVDC**（换相换流高压直流）和 **VSC-HVDC**（电压源换流高压直流）输电技术，实现高效远距离输电与灵活调节。
- **新能源接入**：大规模风电和光伏等新能源逐步接入，对电网的调度和稳定性提出了更高要求。
- **高电压等级**：电网主要采用 **500kV** 和 **220kV** 电压等级，并配备多个直流输电接入点，以满足区域内外的电力需求。

## **3. 苏州电网主要分区**

苏州电网可划分为多个区域，各区域的负荷分布、机组分布及直流输电接入情况如下：

### **(1) 苏南区域**

- **负荷中心**：工业和商业负荷密集，昼夜负荷波动较大。
- **主要机组**：以火电机组为主，辅以少量燃气机组用于调峰。
- **直流接入**：白鹤滩-江苏 ±800kV 直流输电的受端换流站位于该区域，承担主要的直流输电任务。

### **(2) 苏州城区**

- **负荷中心**：商业和居民负荷较高，具有明显的峰谷差。
- **主要机组**：燃气机组和分布式能源（如小型光伏发电）较为普遍。
- **直流接入**：局部配备 **VSC-HVDC**（柔性直流）技术，实现新能源的高效并网。

### **(3) 昆山-太仓片区**

- **负荷中心**：电子产业园和大型制造企业较多，负荷增长迅速。
- **主要机组**：少量燃气机组，新能源（风电、光伏）占比逐步提升。
- **直流接入**：配合华东特高压交直流混合输电系统，提升区域内电力传输能力。

### **(4) 张家港-常熟区域**

- **负荷中心**：重工业和化工企业集中，负荷需求稳定且大。
- **主要机组**：大容量燃煤机组，多条 **500kV** 线路与华东电网互联。
- **直流接入**：部分跨省直流输电接入，增强区域电力供应的可靠性。

## **4. 等值建模方法**

在苏州电网的 DIgSILENT 仿真平台中，我们采用**基于实际数据的等值方法**，对 **220kV** 电磁环网进行等值建模，确保仿真计算的**效率与准确性**。具体方法如下：

### **(1) 等值策略**

- **保留 500kV 主变 220kV 侧的母线**，确保 500kV 及以上电网的潮流和动态特性不受影响。
- **保留所有有机组接入的 220kV 母线**，使发电机的动态行为可用于仿真分析。
- **对其他 220kV 电磁环网进行等值**，减少不必要的计算量，同时保留等效的负荷和电压支撑能力。

### **(2) 等值方法**

等值方法主要包括**拓扑简化**、**导纳等值**和**负荷分配**。

#### **(a) 拓扑等值：构建电网邻接矩阵**

利用以下代码构建稀疏邻接矩阵，表示电网的拓扑结构：

```python
from scipy.sparse import lil_matrix, csr_matrix

def create_sparse_adjacency_matrix(nodes, lines):
    # 使用 (bus_name, vol_rank) 作为唯一标识符，创建节点到索引的映射
    node_index = {(node.bus_name, float(node.vol_rank)): idx for idx, node in enumerate(nodes)}
    n = len(nodes)
    
    # 初始化一个 n x n 的稀疏矩阵（使用 LIL 格式）
    adjacency_matrix = lil_matrix((n, n), dtype=int)
    
    # 遍历每条线路，根据端点的 (bus_name, vol_rank) 填充矩阵
    for line in lines:
        # 获取线路两端节点的唯一标识符
        idx1 = node_index.get((line.bus_name1, float(line.vol_rank1)))
        idx2 = node_index.get((line.bus_name2, float(line.vol_rank2)))
        
        # 若两个节点均存在，则在矩阵中标记连接
        if idx1 is not None and idx2 is not None:
            adjacency_matrix[idx1, idx2] = 1
            adjacency_matrix[idx2, idx1] = 1  # 对称标记
    
    # 将 LIL 格式转换为 CSR 格式，便于后续计算
    return adjacency_matrix.tocsr(), node_index
